/*****************************************************************************
* Model: kaCounter.qm
* File:  ./kaCounter.cpp
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::kaCounter.cpp} ......................................................*/
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cstddef>
#include <cstdint>

#include "qhsm.h"
#include "signals.h"
#include "dispatcher.h"
#include "reasons.h"
#include "bsp.h"
#include "kaCounter.h"

//Q_DEFINE_THIS_FILE


/* global-scope definitions -----------------------------------------*/

/*${SMs::KaCounter_ctor} ...................................................*/
void KaCounter_ctor(
    KaCounter* me,
    Dispatcher* dispatcher,
    KaTetCounters* KaTetTimers,
    KaTetLinks* KaTets,
    NearCharacters* Characters)
{
    me->KaTetTimers = KaTetTimers;
    me->KaTets = KaTets;
    me->Characters = Characters;
    me->dispatcher = dispatcher;
    QHsm_ctor(&me->super, Q_STATE_CAST(&KaCounter_initial));
}


/*${SMs::KaCounter} ........................................................*/
/*${SMs::KaCounter::SM} ....................................................*/
QState KaCounter_initial(KaCounter * const me, QEvt const * const e) {
    /* ${SMs::KaCounter::SM::initial} */
    return Q_TRAN(&KaCounter_idle);
}
/*${SMs::KaCounter::SM::global} ............................................*/
QState KaCounter_global(KaCounter * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {

#ifdef DESKTOP
        /* ${SMs::KaCounter::SM::global::TERMINATE} */
        case TERMINATE_SIG: {
            status_ = Q_TRAN(&KaCounter_final);
            break;
        }
#endif /* def DESKTOP */

        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${SMs::KaCounter::SM::global::ka_tet_counter} ............................*/
QState KaCounter_ka_tet_counter(KaCounter * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::KaCounter::SM::global::ka_tet_counter::TIME_TICK_1M} */
        case TIME_TICK_1M_SIG: {
            SaveCounters(me->KaTetTimers);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&KaCounter_global);
            break;
        }
    }
    return status_;
}
/*${SMs::KaCounter::SM::global::ka_tet_counter::idle} ......................*/
QState KaCounter_idle(KaCounter * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::KaCounter::SM::global::ka_tet_counter::idle::BEGIN(PERSON_NEAR)+BASE} */
        case BEGIN(PERSON_NEAR)+BASE_SIG: {
            /* ${SMs::KaCounter::SM::global::ka_tet_counter::idle::BEGIN(PERSON_NEA~::[(((me->KaTets)->get(((constKaCo~} */
            if ((((me->KaTets)->get(((const KaCounterQEvt*)e)->id)) == false) && (me->Characters->count_ones() == 1)) {
                me->CurrentId = ((const KaCounterQEvt*)e)->id;
                status_ = Q_TRAN(&KaCounter_ka_tet_forming);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /* ${SMs::KaCounter::SM::global::ka_tet_counter::idle::END(PERSON_NEAR)+BASE} */
        case END(PERSON_NEAR)+BASE_SIG: {
            /* ${SMs::KaCounter::SM::global::ka_tet_counter::idle::END(PERSON_NEAR)~::[(me->Characters->count_ones()==~} */
            if ((me->Characters->count_ones() == 1)) {
                me->CurrentId = me->Characters->find_first_one();
                status_ = Q_TRAN(&KaCounter_ka_tet_forming);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&KaCounter_ka_tet_counter);
            break;
        }
    }
    return status_;
}
/*${SMs::KaCounter::SM::global::ka_tet_counter::ka_tet_forming} ............*/
QState KaCounter_ka_tet_forming(KaCounter * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::KaCounter::SM::global::ka_tet_counter::ka_tet_forming::END(PERSON_NEAR)+BASE} */
        case END(PERSON_NEAR)+BASE_SIG: {
            /* ${SMs::KaCounter::SM::global::ka_tet_counter::ka_tet_forming::END(PERSON_NEAR)~::[((constKaCounterQEvt*)e)->id==m~} */
            if (((const KaCounterQEvt*)e)->id == me->CurrentId) {
                status_ = Q_TRAN(&KaCounter_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /* ${SMs::KaCounter::SM::global::ka_tet_counter::ka_tet_forming::BEGIN(PERSON_NEAR)+BASE} */
        case BEGIN(PERSON_NEAR)+BASE_SIG: {
            /* ${SMs::KaCounter::SM::global::ka_tet_counter::ka_tet_forming::BEGIN(PERSON_NEA~::[((constKaCounterQEvt*)e)->id!=m~} */
            if (((const KaCounterQEvt*)e)->id != me->CurrentId) {
                status_ = Q_TRAN(&KaCounter_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /* ${SMs::KaCounter::SM::global::ka_tet_counter::ka_tet_forming::TIME_TICK_1S} */
        case TIME_TICK_1S_SIG: {
            /* ${SMs::KaCounter::SM::global::ka_tet_counter::ka_tet_forming::TIME_TICK_1S::[((*(me->KaTetTimers))[me->Curre~} */
            if (((*(me->KaTetTimers))[me->CurrentId] >= KATET_THRESHOLD)) {
                DISPATCH_ONESHOT_WITH_PARAM(FORM_KATET,  me->CurrentId);
                status_ = Q_TRAN(&KaCounter_idle);
            }
            /* ${SMs::KaCounter::SM::global::ka_tet_counter::ka_tet_forming::TIME_TICK_1S::[else]} */
            else {
                (*(me->KaTetTimers))[me->CurrentId]++;
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&KaCounter_ka_tet_counter);
            break;
        }
    }
    return status_;
}

#ifdef DESKTOP
/*${SMs::KaCounter::SM::final} .............................................*/
QState KaCounter_final(KaCounter * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::KaCounter::SM::final} */
        case Q_ENTRY_SIG: {
            printf("Bye! Bye!"); exit(0);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
#endif /* def DESKTOP */





