/*****************************************************************************
* Model: kaTet.qm
* File:  ./kaTet.cpp
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::kaTet.cpp} ..........................................................*/
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cstddef>
#include <cstdint>

#include "qhsm.h"
#include "signals.h"
#include "dispatcher.h"
#include "reasons.h"
#include "bsp.h"
#include "kaTet.h"

//Q_DEFINE_THIS_FILE

#define MEDIUM_VIBRO 200

/* global-scope definitions -----------------------------------------*/

/*${SMs::KaTet_ctor} .......................................................*/
void KaTet_ctor(
    KaTet* me,
    Dispatcher* dispatcher,
    KaTetLinks* KaTets)
{
    me->KaTets = KaTets;
    me->KaTetNear = 0;
    if (me->KaTets->empty()) {
        me->StartState = (QStateHandler)&KaTet_alone;
    } else {
        me->StartState = (QStateHandler)&KaTet_faraway;
    }
    me->dispatcher = dispatcher;
    QHsm_ctor(&me->super, Q_STATE_CAST(&KaTet_initial));
}


/*${SMs::KaTet} ............................................................*/
/*${SMs::KaTet::SM} ........................................................*/
QState KaTet_initial(KaTet * const me, QEvt const * const e) {
    /* ${SMs::KaTet::SM::initial} */
    return Q_TRAN(me->StartState);
    return Q_TRAN(&KaTet_alone);
}
/*${SMs::KaTet::SM::global} ................................................*/
QState KaTet_global(KaTet * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {

#ifdef DESKTOP
        /* ${SMs::KaTet::SM::global::TERMINATE} */
        case TERMINATE_SIG: {
            status_ = Q_TRAN(&KaTet_final);
            break;
        }
#endif /* def DESKTOP */

        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${SMs::KaTet::SM::global::has_katet} .....................................*/
QState KaTet_has_katet(KaTet * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::KaTet::SM::global::has_katet} */
        case Q_ENTRY_SIG: {
            SaveKatet(me->KaTets);
                me->KaTetNear = 0;
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::KaTet::SM::global::has_katet} */
        case Q_EXIT_SIG: {
            ScreenAddBMPToQueue("Katet_destroyed.bmp");
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::KaTet::SM::global::has_katet::BEGIN(FORM_KATET)+BASE} */
        case BEGIN(FORM_KATET)+BASE_SIG: {
            (me->KaTets)->set(((const KaTetQEvt*)e)->id, true);
                ScreenAddBMPToQueue("Katet.bmp");
                Vibro(MEDIUM_VIBRO, 2);
                SaveKatet(me->KaTets);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::KaTet::SM::global::has_katet::BEGIN(DESTROY_KATET)+BASE} */
        case BEGIN(DESTROY_KATET)+BASE_SIG: {
            (me->KaTets)->clear();
                SaveKatet(me->KaTets);
                DISPATCH_ONESHOT(KATET_DESTROYED);
            status_ = Q_TRAN(&KaTet_alone);
            break;
        }
        default: {
            status_ = Q_SUPER(&KaTet_global);
            break;
        }
    }
    return status_;
}
/*${SMs::KaTet::SM::global::has_katet::near} ...............................*/
QState KaTet_near(KaTet * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::KaTet::SM::global::has_katet::near} */
        case Q_ENTRY_SIG: {
            DISPATCH_BEGIN(KATET_NEAR);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::KaTet::SM::global::has_katet::near} */
        case Q_EXIT_SIG: {
            DISPATCH_END(KATET_NEAR);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::KaTet::SM::global::has_katet::near::BEGIN(PERSON_NEAR)+BASE} */
        case BEGIN(PERSON_NEAR)+BASE_SIG: {
            if ((me->KaTets)->get(((const KaTetQEvt*)e)->id) == true) {
                    me->KaTetNear++;
                }
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::KaTet::SM::global::has_katet::near::END(PERSON_NEAR)+BASE} */
        case END(PERSON_NEAR)+BASE_SIG: {
            /* ${SMs::KaTet::SM::global::has_katet::near::END(PERSON_NEAR)~::[me->KaTetNear<=1]} */
            if (me->KaTetNear <= 1) {
                me->KaTetNear = 0;
                status_ = Q_TRAN(&KaTet_faraway);
            }
            /* ${SMs::KaTet::SM::global::has_katet::near::END(PERSON_NEAR)~::[else]} */
            else {
                me->KaTetNear--;
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&KaTet_has_katet);
            break;
        }
    }
    return status_;
}
/*${SMs::KaTet::SM::global::has_katet::faraway} ............................*/
QState KaTet_faraway(KaTet * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::KaTet::SM::global::has_katet::faraway} */
        case Q_ENTRY_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::KaTet::SM::global::has_katet::faraway::BEGIN(PERSON_NEAR)+BASE} */
        case BEGIN(PERSON_NEAR)+BASE_SIG: {
            /* ${SMs::KaTet::SM::global::has_katet::faraway::BEGIN(PERSON_NEA~::[(me->KaTets)->get(((constKaTetQ~} */
            if ((me->KaTets)->get(((const KaTetQEvt*)e)->id) == true) {
                status_ = Q_TRAN(&KaTet_near);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&KaTet_has_katet);
            break;
        }
    }
    return status_;
}
/*${SMs::KaTet::SM::global::alone} .........................................*/
QState KaTet_alone(KaTet * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::KaTet::SM::global::alone::BEGIN(FEAR_PLACE)+BASE} */
        case BEGIN(FEAR_PLACE)+BASE_SIG: {
            DISPATCH_BEGIN(FEAR);
            ScreenAddBMPToQueue("Fear.bmp");
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::KaTet::SM::global::alone::END(FEAR_PLACE)+BASE} */
        case END(FEAR_PLACE)+BASE_SIG: {
            DISPATCH_END(FEAR);
            status_ = Q_HANDLED();
            break;
        }
        /* ${SMs::KaTet::SM::global::alone::BEGIN(FORM_KATET)+BASE} */
        case BEGIN(FORM_KATET)+BASE_SIG: {
            (me->KaTets)->set(((const KaTetQEvt*)e)->id, true);
                ScreenAddBMPToQueue("Ka_tet.bmp");
                Vibro(MEDIUM_VIBRO, 2);
            status_ = Q_TRAN(&KaTet_faraway);
            break;
        }
        default: {
            status_ = Q_SUPER(&KaTet_global);
            break;
        }
    }
    return status_;
}

#ifdef DESKTOP
/*${SMs::KaTet::SM::final} .................................................*/
QState KaTet_final(KaTet * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${SMs::KaTet::SM::final} */
        case Q_ENTRY_SIG: {
            printf("Bye! Bye!"); exit(0);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
#endif /* def DESKTOP */





